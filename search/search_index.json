{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Sipi is a high-performance, IIIF compatible media server developed by the Digital Humanities Lab at the University of Basel . It is designed to be used by archives, libraries, and other institutions that need to preserve high-quality images while making them available online. Sipi implements the International Image Interoperability Framework ( IIIF ), and efficiently converts between image formats, preserving metadata contained in image files. In particular, if images are stored in JPEG 2000 format, Sipi can convert them on the fly to formats that are commonly used on the Internet. Sipi offers a flexible framework for specifying authentication and authorization logic in Lua scripts, and supports restricted access to images, either by reducing image dimensions or by adding watermarks. It can easily be integrated with Knora . In addition SIPI preserves most of the EXIF , IPTC and XMP metadata and can preserve or transform ICC colour profiles. In addition, a simple webserver is integrated. The server is able to serve most common file types. In addition Lua scripts and embedded Lua (i.e., Lua embedded into HTML pages using the tags <lua>\u2026</lua> are supported. Sipi can also be used from the command line to convert images to/from TIFF_, JPEG 2000 , JPEG_ and PNG_ formats. For all these conversion, Sipi tries to preserve all embedded metadata such as IPTC , EXIF , XMP and ICC color profiles. However, due to the limitations of some file formats, it cannot be guaranteed that all metadata and ICC profiles are preserved. JPEG 2000 does not allow all types of ICC profiles. Unsupported profile types will be added to the JPEG 2000 header as comment and will be reinstated if the JPEG 2000 file is converted back to the TIFF_ format. Sipi is free software , released under the GNU Affero General Public License . It is written in C++ and runs on Linux (including Debian , Ubuntu , and CentOS ) and Mac OS X. Freely distributable binary releases are available.","title":"Overview"},{"location":"#overview","text":"Sipi is a high-performance, IIIF compatible media server developed by the Digital Humanities Lab at the University of Basel . It is designed to be used by archives, libraries, and other institutions that need to preserve high-quality images while making them available online. Sipi implements the International Image Interoperability Framework ( IIIF ), and efficiently converts between image formats, preserving metadata contained in image files. In particular, if images are stored in JPEG 2000 format, Sipi can convert them on the fly to formats that are commonly used on the Internet. Sipi offers a flexible framework for specifying authentication and authorization logic in Lua scripts, and supports restricted access to images, either by reducing image dimensions or by adding watermarks. It can easily be integrated with Knora . In addition SIPI preserves most of the EXIF , IPTC and XMP metadata and can preserve or transform ICC colour profiles. In addition, a simple webserver is integrated. The server is able to serve most common file types. In addition Lua scripts and embedded Lua (i.e., Lua embedded into HTML pages using the tags <lua>\u2026</lua> are supported. Sipi can also be used from the command line to convert images to/from TIFF_, JPEG 2000 , JPEG_ and PNG_ formats. For all these conversion, Sipi tries to preserve all embedded metadata such as IPTC , EXIF , XMP and ICC color profiles. However, due to the limitations of some file formats, it cannot be guaranteed that all metadata and ICC profiles are preserved. JPEG 2000 does not allow all types of ICC profiles. Unsupported profile types will be added to the JPEG 2000 header as comment and will be reinstated if the JPEG 2000 file is converted back to the TIFF_ format. Sipi is free software , released under the GNU Affero General Public License . It is written in C++ and runs on Linux (including Debian , Ubuntu , and CentOS ) and Mac OS X. Freely distributable binary releases are available.","title":"Overview"},{"location":"building/","text":"Building Sipi from Source Code Prerequisites To build Sipi from source code, you must have Kakadu , a JPEG 2000 development toolkit that is not provided with Sipi and must be licensed separately. The Kakadu source code archive v7_A_7-01382N.zip must be placed in the vendor subdirectory of the source tree before building Sipi. Sipi's build process requires CMake (minimal Version 3.0.0), a C++ compiler that supports the C++11 standard (such as GCC or clang ), and several libraries that are readily available on supported platforms. The test framework requires Python 3 , (version 3.5 or later), Apache ab (which is assumed to be installed by default on macOS Sierra), nginx , and a recent version of ImageMagick . Instructions for installing these prerequisites are given below. The build process downloads and builds Sipi's other prerequisites. Sipi uses the Adobe ICC Color profiles, which are automatically downloaded by the build process into the file icc.zip . The user is responsible for reading and agreeing with Adobe's license conditions, which are specified in the file Color Profile EULA.pdf . macOS You will need Homebrew and at least OSX 10.11.5. Prerequisites for building Sipi without its automated test framework: xcode-select --install brew install cmake brew install doxygen brew install openssl brew install libmagic brew install gettext brew install libidn If you also want to run Sipi's tests: brew install nginx sudo chown -R $USER /usr/local/var/log/nginx/ brew install imagemagick --with-openjpeg brew install python3 pip3 install Sphinx pip3 install pytest pip3 install requests pip3 install psutil pip3 install iiif_validator Ubuntu 18.04 Prerequisites for building Sipi without its automated test framework: sudo apt-get install g++-7 sudo apt-get install cmake sudo apt-get install libssl-dev sudo apt-get install doxygen sudo apt-get install libreadline-dev sudo apt-get install gettext sudo apt-get install libmagic-dev sudo apt-get install unzip sudo apt-get install libidn11-dev If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo apt-get install libtiff5-dev libjpeg-turbo8-dev libopenjp2-7-dev wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo apt-get install ab sudo apt-get install nginx sudo chown -R $USER /var/log/nginx sudo apt-get install python3 sudo apt-get install python3-pip sudo -H pip3 install --upgrade pip sudo -H pip3 install Sphinx sudo -H pip3 install pytest sudo -H pip3 install requests sudo -H pip3 install psutil sudo -H pip3 install iiif_validator Debian 8 First, follow the instructions for ubuntu-build. Then, CMake has to be patched. Unfortunaltely the version of CMake provided by the Debian packages contains a bug and cannot find the OpenSSL libraries and includes. To apply the patch, go to the Sipi dicrectory and run: sudo ./debian-cmake-patch.sh CentOS 7 This requires GCC version 5.3 or greater. You can install it by installing devtoolset-4 , and adding this to your .bash_profile : source scl_source enable devtoolset-4 Prerequisites for building Sipi without its automated test framework: sudo yum -y install cmake3 sudo yum -y install readline-devel sudo yum -y install doxygen sudo yum -y install patch sudo yum -y install openssl-devel sudo yum -y install gettext sudo yum -y install file-devel If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo yum install libtiff-devel libjpeg-turbo-devel openjpeg2-devel wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo yum -y install httpd-tools sudo yum -y install nginx sudo chown -R $USER /var/log/nginx sudo chown -R $USER /var/lib/nginx sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm sudo yum -y install python35u sudo yum -y install python35u-devel sudo yum -y install python35u-pip sudo pip3.5 install Sphinx sudo pip3.5 install pytest sudo pip3.5 install requests sudo pip3.5 install psutil sudo pip3.5 install iiif_validator Docker We provide a docker image based on Ubuntu LTS releases, containing all dependencies: https://hub.docker.com/r/dhlabbasel/sipi-base/ Compiling the Source Code Start in the build subdirectory of the source tree: cd build Then compile Sipi: cmake .. make By default, Sipi is built without optimization and with debug information output. To compile Sipi with optimization level 3, run: cmake .. -DMAKE_DEBUG:BOOL=OFF make Running Tests You can run the automated tests in the build directory like this: make test // will run all tests (minimum output) ctest --verbose // will run all tests (detailed output) make check // will run only e2e tests (detailed output) Making a Directory Tree for Installing Sipi In build , type this to install Sipi in the local subdirectory of the source tree: make install You can then copy the contents of local to the desired location. Generating Documentation To generate this manual in HTML format, cd to the manual subdirectory of the source tree and type: make html You will then find the manual under manual/_build/html . To generate developer documentation about Sipi's C++ internals, cd to the build directory and type: make doc You will find the developer documentation in HTML format under doc/html . To generate developer documentation in PDF format, first ensure that you have LaTeX installed. Then cd to doc/html/latex and type make . Starting Over To delete the previous build and start over from scratch, cd to the top level of the source tree and type: rm -rf build/* lib local extsrcs include/*_icc.h Building inside Docker All that was described before, can also be done by using docker. All commands need to be executed from inside the source directory (and not build the build directory). Also, Docker needs to be installed on the system. // deletes cached image and needs only to be used when newer image is available on dockerhub docker image rm --force dhlabbasel/sipi-base:18.04 // building docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make\" // building and running all tests docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make && ctest --verbose\" // make html documentation docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/manual; make html\" Since we mount the current source directory into the docker container, all build artifacts can be accessed as if the build would have been performed without docker.","title":"Building"},{"location":"building/#building-sipi-from-source-code","text":"","title":"Building Sipi from Source Code"},{"location":"building/#prerequisites","text":"To build Sipi from source code, you must have Kakadu , a JPEG 2000 development toolkit that is not provided with Sipi and must be licensed separately. The Kakadu source code archive v7_A_7-01382N.zip must be placed in the vendor subdirectory of the source tree before building Sipi. Sipi's build process requires CMake (minimal Version 3.0.0), a C++ compiler that supports the C++11 standard (such as GCC or clang ), and several libraries that are readily available on supported platforms. The test framework requires Python 3 , (version 3.5 or later), Apache ab (which is assumed to be installed by default on macOS Sierra), nginx , and a recent version of ImageMagick . Instructions for installing these prerequisites are given below. The build process downloads and builds Sipi's other prerequisites. Sipi uses the Adobe ICC Color profiles, which are automatically downloaded by the build process into the file icc.zip . The user is responsible for reading and agreeing with Adobe's license conditions, which are specified in the file Color Profile EULA.pdf .","title":"Prerequisites"},{"location":"building/#macos","text":"You will need Homebrew and at least OSX 10.11.5. Prerequisites for building Sipi without its automated test framework: xcode-select --install brew install cmake brew install doxygen brew install openssl brew install libmagic brew install gettext brew install libidn If you also want to run Sipi's tests: brew install nginx sudo chown -R $USER /usr/local/var/log/nginx/ brew install imagemagick --with-openjpeg brew install python3 pip3 install Sphinx pip3 install pytest pip3 install requests pip3 install psutil pip3 install iiif_validator","title":"macOS"},{"location":"building/#ubuntu-1804","text":"Prerequisites for building Sipi without its automated test framework: sudo apt-get install g++-7 sudo apt-get install cmake sudo apt-get install libssl-dev sudo apt-get install doxygen sudo apt-get install libreadline-dev sudo apt-get install gettext sudo apt-get install libmagic-dev sudo apt-get install unzip sudo apt-get install libidn11-dev If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo apt-get install libtiff5-dev libjpeg-turbo8-dev libopenjp2-7-dev wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo apt-get install ab sudo apt-get install nginx sudo chown -R $USER /var/log/nginx sudo apt-get install python3 sudo apt-get install python3-pip sudo -H pip3 install --upgrade pip sudo -H pip3 install Sphinx sudo -H pip3 install pytest sudo -H pip3 install requests sudo -H pip3 install psutil sudo -H pip3 install iiif_validator","title":"Ubuntu 18.04"},{"location":"building/#debian-8","text":"First, follow the instructions for ubuntu-build. Then, CMake has to be patched. Unfortunaltely the version of CMake provided by the Debian packages contains a bug and cannot find the OpenSSL libraries and includes. To apply the patch, go to the Sipi dicrectory and run: sudo ./debian-cmake-patch.sh","title":"Debian 8"},{"location":"building/#centos-7","text":"This requires GCC version 5.3 or greater. You can install it by installing devtoolset-4 , and adding this to your .bash_profile : source scl_source enable devtoolset-4 Prerequisites for building Sipi without its automated test framework: sudo yum -y install cmake3 sudo yum -y install readline-devel sudo yum -y install doxygen sudo yum -y install patch sudo yum -y install openssl-devel sudo yum -y install gettext sudo yum -y install file-devel If you also want to run Sipi's tests, you will need ImageMagick , version 7.0.6 or higher. We suggest compiling it from source: sudo yum install libtiff-devel libjpeg-turbo-devel openjpeg2-devel wget https://github.com/ImageMagick/ImageMagick/archive/7.0.6-0.tar.gz tar -xzf 7.0.6-0.tar.gz cd ImageMagick-7.0.6-0/ ./configure make sudo make install sudo ldconfig /usr/local/lib Then: sudo yum -y install httpd-tools sudo yum -y install nginx sudo chown -R $USER /var/log/nginx sudo chown -R $USER /var/lib/nginx sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm sudo yum -y install python35u sudo yum -y install python35u-devel sudo yum -y install python35u-pip sudo pip3.5 install Sphinx sudo pip3.5 install pytest sudo pip3.5 install requests sudo pip3.5 install psutil sudo pip3.5 install iiif_validator","title":"CentOS 7"},{"location":"building/#docker","text":"We provide a docker image based on Ubuntu LTS releases, containing all dependencies: https://hub.docker.com/r/dhlabbasel/sipi-base/","title":"Docker"},{"location":"building/#compiling-the-source-code","text":"Start in the build subdirectory of the source tree: cd build Then compile Sipi: cmake .. make By default, Sipi is built without optimization and with debug information output. To compile Sipi with optimization level 3, run: cmake .. -DMAKE_DEBUG:BOOL=OFF make","title":"Compiling the Source Code"},{"location":"building/#running-tests","text":"You can run the automated tests in the build directory like this: make test // will run all tests (minimum output) ctest --verbose // will run all tests (detailed output) make check // will run only e2e tests (detailed output)","title":"Running Tests"},{"location":"building/#making-a-directory-tree-for-installing-sipi","text":"In build , type this to install Sipi in the local subdirectory of the source tree: make install You can then copy the contents of local to the desired location.","title":"Making a Directory Tree for Installing Sipi"},{"location":"building/#generating-documentation","text":"To generate this manual in HTML format, cd to the manual subdirectory of the source tree and type: make html You will then find the manual under manual/_build/html . To generate developer documentation about Sipi's C++ internals, cd to the build directory and type: make doc You will find the developer documentation in HTML format under doc/html . To generate developer documentation in PDF format, first ensure that you have LaTeX installed. Then cd to doc/html/latex and type make .","title":"Generating Documentation"},{"location":"building/#starting-over","text":"To delete the previous build and start over from scratch, cd to the top level of the source tree and type: rm -rf build/* lib local extsrcs include/*_icc.h","title":"Starting Over"},{"location":"building/#building-inside-docker","text":"All that was described before, can also be done by using docker. All commands need to be executed from inside the source directory (and not build the build directory). Also, Docker needs to be installed on the system. // deletes cached image and needs only to be used when newer image is available on dockerhub docker image rm --force dhlabbasel/sipi-base:18.04 // building docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make\" // building and running all tests docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/build; cmake .. && make && ctest --verbose\" // make html documentation docker run --rm -v $PWD:/sipi dhlabbasel/sipi-base:18.04 /bin/sh -c \"cd /sipi/manual; make html\" Since we mount the current source directory into the docker container, all build artifacts can be accessed as if the build would have been performed without docker.","title":"Building inside Docker"},{"location":"developing/","text":"Developing Sipi Using an IDE CLion If you are using the CLion IDE, put -j 1 in Preferences -> Build, Execution, Deployment -> CMake -> Build options, to prevent CMake from building with multiple processes. Also, note that code introspection in the CLion editor may not work until it has run CMake. Code::Blocks If you are using the Code::Blocks_ IDE, you can build a cdb project: cd build cmake .. -G \"CodeBlocks - Unix Makefiles\" Writing Tests We use two test frameworks. We use googletest for unit test and pytest for end-to-end tests. Unit Tests TBA End-to-End Tests To add end-to-end tests, add a Python class in a file whose name begins with test , in the test directory. The class's methods, whose names must also begin with test , should use the manager fixture defined in test/conftest.py , which handles starting and stopping a Sipi server, and provides other functionality useful in tests. See the existing test/test_*.py files for examples. To facilitate testing client HTTP connections in Lua scripts, the manager fixture also starts and stops an nginx instance, which can be used to simulate an authorization server. For example, the provided nginx configuration file, test/nginx/nginx.conf , allows nginx to act as a dummy Knora API server for permission checking: its /v1/files route returns a static JSON file that always grants permission to view the requested file. Commit Message Schema When writing commit messages, we stick to this schema: type (scope): subject body Types: feature (new feature for the user) fix (bug fix for the user) docs (changes to the documentation) style (formatting, etc) refactor (refactoring production code, e.g. renaming a variable) test (adding missing tests, refactoring tests) build (changes to CMake configuration, etc.) enhancement (residual category) Example: feature (HTTP server): support more authentication methods","title":"Developing"},{"location":"developing/#developing-sipi","text":"","title":"Developing Sipi"},{"location":"developing/#using-an-ide","text":"","title":"Using an IDE"},{"location":"developing/#clion","text":"If you are using the CLion IDE, put -j 1 in Preferences -> Build, Execution, Deployment -> CMake -> Build options, to prevent CMake from building with multiple processes. Also, note that code introspection in the CLion editor may not work until it has run CMake.","title":"CLion"},{"location":"developing/#codeblocks","text":"If you are using the Code::Blocks_ IDE, you can build a cdb project: cd build cmake .. -G \"CodeBlocks - Unix Makefiles\"","title":"Code::Blocks"},{"location":"developing/#writing-tests","text":"We use two test frameworks. We use googletest for unit test and pytest for end-to-end tests.","title":"Writing Tests"},{"location":"developing/#unit-tests","text":"TBA","title":"Unit Tests"},{"location":"developing/#end-to-end-tests","text":"To add end-to-end tests, add a Python class in a file whose name begins with test , in the test directory. The class's methods, whose names must also begin with test , should use the manager fixture defined in test/conftest.py , which handles starting and stopping a Sipi server, and provides other functionality useful in tests. See the existing test/test_*.py files for examples. To facilitate testing client HTTP connections in Lua scripts, the manager fixture also starts and stops an nginx instance, which can be used to simulate an authorization server. For example, the provided nginx configuration file, test/nginx/nginx.conf , allows nginx to act as a dummy Knora API server for permission checking: its /v1/files route returns a static JSON file that always grants permission to view the requested file.","title":"End-to-End Tests"},{"location":"developing/#commit-message-schema","text":"When writing commit messages, we stick to this schema: type (scope): subject body Types: feature (new feature for the user) fix (bug fix for the user) docs (changes to the documentation) style (formatting, etc) refactor (refactoring production code, e.g. renaming a variable) test (adding missing tests, refactoring tests) build (changes to CMake configuration, etc.) enhancement (residual category) Example: feature (HTTP server): support more authentication methods","title":"Commit Message Schema"},{"location":"lua/","text":"Customizing Sipi with Lua Scripts Within Sipi, Lua is used to perform authentication and authorization for IIIF image requests, and to write custom routes. Sipi provides the Lua interpreter the LuaRocks package manager. Sipi does not use the system's Lua interpreter or package manager. The Lua interpreter in Sipi runs in a multithreaded environment: each request runs in its own thread and has its own Lua interpreter. Therefore, only Lua packages that are known to be thread-safe may be used. Custom Routes Custom routes can be defined in Sipi's configuration file using the routes configuration variable. For example: routes = { { method = 'GET', route = '/status', script = 'get_repository_status.lua' }, { method = 'POST', route = '/make_thumbnail', script = 'make_image_thumbnail.lua' } } Sipi looks for these scripts in the directory specified by scriptdir in its configuration file. The first route that matches the beginning of the requested URL path will be used. Authentication and Authorization In Sipi's config file, initscript contains the path of a Lua script that defines a function called pre_flight . The function takes the parameters prefix , identifier and, cookie , and is called whenever an image is requested. The possible return values of the pre_flight function are as follows. Note that Lua function's return value may consist of more than one element (see Multiple Results ): Grant full permissions to access the file identified by filepath : return 'allow', filepath Grant restricted access to the file identified by filepath , in one of the following ways: : - Reduce the image dimensions, e.g. to the default thumbnail dimensions: return 'restrict:size=' .. \"config.thumb_size\", filepath - Render the image with a watermark: return restrict:watermark=<path-to-watermark>, filepath Deny access to the requested file: return 'deny' In the pre_flight function, permission checking can be implemented. When Sipi is used with Knora , the pre_flight function asks Knora about the user's permissions on the image (see sipi.init-knora.lua ). The scripts Knora_login.lua and Knora_logout.lua handle the setting and unsetting of a cookie containing the Knora session ID. File uploads to SIPI Using Lua it is possible to create an upload function for image files. See the scripts upload.elua and do-upload.elua in the server directory, or upload.lua in the scripts directory. Sipi Functions Available to Lua Scripts Sipi provides the following functions that can be called from Lua scripts. Each function returns two values. The first value is true if the operation succeeded, false otherwise. If the operation succeeded, the second value is the result of the operation, otherwise it is an error message. server.setBuffer success, errmsg = server.setBuffer([bufsize][,incsize]) Activates the the connection buffer. Optionally the buffer size and increment size can be given. Returns true, nil on success or false, errormsg on failure. server.fs.ftype success, filetype = server.fs.ftype(filepath) Checks the filetype of a given filepath. Returns either true, filetype (one of \"FILE\" , \"DIRECTORY\" , \"CHARDEV\" , \"BLOCKDEV\" , \"LINK\" , \"SOCKET\" or \"UNKNOWN\" ) or false, errormsg . server.fs.modtime success, modtime = server.fs.modtime(filepath) Retrieves the last modification date of a file in seconds since epoch UTC. Returns either true , modtime or false , errormsg . server.fs.is_readable success, readable = server.fs.is_readable(filepath) Checks if a file is readable. Returns true, readable (boolean) on success or false, errormsg on failure. server.fs.is_writeable success, writeable = server.fs.is_writeable(filepath) Checks if a file is writeable. Returns true, writeable (boolean) on success or false, errormsg on failure. server.fs.is_executable success, errormsg = server.fs.is_executable(filepath) Checks if a file is executable. Returns true, executable (boolean) on success or false, errormsg on failure. server.fs.exists success, exists = server.fs.exists(filepath) Checks if a file exists. Checks if a file exists. Returns true, exists (boolean) on success or false, errormsg on failure. server.fs.unlink success, errormsg = server.fs.unlink(filename) Deletes a file from the file system. The file must exist and the user must have write access. Returns true, nil on success or false, errormsg on failure. server.fs.mkdir success, errormsg = server.fs.mkdir(dirname, [tonumber('0755', 8)]) Creates a new directory, optionally with the specified permissions. Returns true, nil on success or false, errormsg on failure. server.fs.rmdir success, errormsg = server.fs.rmdir(dirname) Deletes a directory. Returns true, nil on success or false, errormsg on failure. server.fs.getcwd success, curdir = server.fs.getcwd() Gets the current working directory. Returns true, current_dir on success or false, errormsg on failure. server.fs.readdir success, filenames = server.fs.readdir(dirname) Gets the names of the files in a directory, not including . and .. . Returns true, table on success or false, errormsg on failure. server.fs.chdir success, oldir = server.fs.chdir(newdir) Change working directory. Returns true, olddir on success or false, errormsg on failure. server.fs.copyFile success, errormsg = server.fs.copyFile(source, destination) Copies a file from source to destination. Returns true, nil on success or false, errormsg on failure. server.fs.moveFile success, errormsg = server.fs.moveFile(from, to) Moves a file. The move connot cross filesystem boundaries! true, nil on success or false, errormsg on failure. server.uuid success, uuid = server.uuid() Generates a random UUID version 4 identifier in canonical form, as described in RFC 4122 . Returns true, uuid on success or false, errormsg on failure. server.uuid62 success, uuid62 = server.uuid62() Generates a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure. server.uuid_to_base62 success, uuid62 = server.uuid_to_base62(uuid) Converts a canonical UUID string to a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure. server.base62_to_uuid success, uuid = server.base62_to_uuid(uuid62) Converts a Base62-encoded UUID to canonical form. Returns true, uuid on success or false, errormsg on failure. server.print success, errormsg = server.print(values) Prints variables and/or strings to the HTTP connection. Returns true, nil on success or false, errormsg on failure. server.http success, result = server.http(method, \"http://server.domain[:port]/path/file\" [, header] [, timeout]) Performs an HTTP request. Parameters: method : The HTTP request method. Currently must be \"GET\" . url : The HTTP URL. header : An optional table of key-value pairs representing HTTP request headers. timeout : An optional number of milliseconds until the connection times out. Authentication is not yet supported. The result is a table: result = { status_code = value -- HTTP status code returned erromsg = \"error description\" -- only if success is false header = { name = value [, name = value, ...] }, certificate = { -- only if HTTPS connection subject = value, issuer = value }, body = data, duration = milliseconds } Example: success, result = server.http(\"GET\", \"http://www.salsah.org/api/resources/1\", 100) if (result.success) then server.print(\"<table>\") server.print(\"<tr><th>Field</th><th>Value</th></tr>\") for k,v in pairs(server.header) do server.print(\"<tr><td>\", k, \"</td><td>\", v, \"</td></tr>\") end server.print(\"</table><hr/>\") server.print(\"Duration: \", result.duration, \" ms<br/><hr/>\") server.print(\"Body:<br/>\", result.body) else server.print(\"ERROR: \", result.errmsg) end server.table_to_json :: : success, jsonstr = server.table_to_json(table) Converts a (nested) Lua table to a JSON string. Returns true, jsonstr on success or false, errormsg on failure. server.json_to_table success, table = server.json_to_table(jsonstr) Converts a JSON string to a (nested) Lua table. Returns true, table on success or false, errormsg on failure. server.sendHeader success, errormsg = server.sendHeader(key, value) Sets an HTTP response header. Returns true, nil on success or false, errormsg on failure. server.sendCookie success, errormsg = server.sendCookie(key, value [, options-table]) Sets a cookie in the HTTP response. Returns true, nil on success or false, errormsg on failure. The optional options-table is a Lua table containing the following keys: path domain expires (value in seconds) secure (boolean) http_only (boolean) server.sendStatus server.sendStatus(code) Sends an HTTP status code. This function is always successful and returns nothing. server.generate_jwt success, token = server.generate_jwt(table) Generates a JSON Web Token (JWT) with the table as payload. Returns true, token on success or false, errormsg on failure. The table contains the JWT claims as follows. (The type IntDate is a number of seconds since 1970-01-01T0:0:0Z): iss (string => StringOrURI) OPT: principal that issued the JWT. exp (number => IntDate) OPT: expiration time on or after which the token MUST NOT be accepted for processing. nbf (number => IntDate) OPT: identifies the time before which the token MUST NOT be accepted for processing. iat (number => IntDate) OPT: identifies the time at which the JWT was issued. aud (string => StringOrURI) OPT: identifies the audience that the JWT is intended for. The audience value is a string, typically the base address of the resource being accessed, such as https://contoso.com . prn (string => StringOrURI) OPT: identifies the subject of the JWT. jti (string => String) OPT: provides a unique identifier for the JWT. server.decode_jwt success, table = server.decode_jwt(token) Decodes a JSON Web Token (JWT) and returns its content as table. Returns true, table on success or false, errormsg on failure. server.file_mimetype success, table = server.file_mimetype(path) success, table = server.file_mimetype(index) Determines the mimetype of a file. The first form is used if the file path is known. The second form can be used for uploads by passing the file index. It returns true, table on success or false, errormsg on failure. The table has 2 members: - mimetype - charset server.requireAuth success, table = server.requireAuth() Gets HTTP authentication data. Returns true, table on success or false, errormsg on failure. The result is a table: { status = string -- \"BASIC\" | \"BEARER\" | \"NOAUTH\" (no authorization header) | \"ERROR\" username = string -- only if status = \"BASIC\" password = string -- only if status = \"BASIC\" token = string -- only if status = \"BEARER\" message = string -- only if status = \"ERROR\" } Example: success, auth = server.requireAuth() if not success then server.sendStatus(501) server.print(\"Error in getting authentication scheme!\") return -1 end if auth.status == 'BASIC' then -- -- everything OK, let's create the token for further calls and ad it to a cookie -- if auth.username == config.adminuser and auth.password == config.password then tokendata = { iss = \"sipi.unibas.ch\", aud = \"knora.org\", user = auth.username } success, token = server.generate_jwt(tokendata) if not success then server.sendStatus(501) server.print(\"Could not generate JWT!\") return -1 end success, errormsg = server.sendCookie('sipi', token, {path = '/', expires = 3600}) if not success then server.sendStatus(501) server.print(\"Couldn't send cookie with JWT!\") return -1 end else server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') server.print(\"Wrong credentials!\") return -1 end elseif auth.status == 'BEARER' then success, jwt = server.decode_jwt(auth.token) if not success then server.sendStatus(501) server.print(\"Couldn't deocde JWT!\") return -1 end if (jwt.iss ~= 'sipi.unibas.ch') or (jwt.aud ~= 'knora.org') or (jwt.user ~= config.adminuser) then server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end elseif auth.status == 'NOAUTH' then server.setBuffer() server.sendStatus(401); server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 else server.status(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end server.copyTmpfile success, errormsg = server.copyTmpfile() Sipi saves each uploaded file in a temporary location (given by the config variable tmpdir ) and deletes it after the request has been served. This function is used to copy the file to another location where it can be retrieved later. Returns true, nil on success or false, errormsg on failure. server.systime systime = server.systime() Returns the current system time on the server in seconds since epoch. server.log server.log(message, loglevel) Writes a message to syslog . Severity levels are: server.loglevel.LOG_EMERG server.loglevel.LOG_ALERT server.loglevel.LOG_CRIT server.loglevel.LOG_ERR server.loglevel.LOG_WARNING server.loglevel.LOG_NOTICE server.loglevel.LOG_INFO server.loglevel.LOG_DEBUG Sipi Variables Available to Lua Scripts config.hostname : Hostname where SIPI runs on config.port : Portnumber where SIPI communicates (non SSL) config.sslport : Portnumber for SSL connections of SIPI config.imgroot : Root directory for IIIF-served images config.docroot : Root directory for WEB-Server config.max_temp_file_age : maximum age of temporary files config.prefix_as_path : true if the prefix should be used as internal path image directories config.init_script : Path to initialization script config.scriptdir : Path to script directory config.cache_dir : Path to cache directory for iIIF served images config.cache_size : Maximal size of cache config.cache_n_files : Maximal number of files in cache config.cache_hysteresis : Amount fo data to be purged if cache reaches maximum size config.keep_alive : keep alive time config.thumb_size : Default thumbnail image size config.n_threads : Number of threads SIPI uses config.max_post_size : Maximal size of POST data allowed config.tmpdir : Temporary directory to store uploads config.knora_path : Path to knora REST API (only for SIPI used with Knora) config.knora_port : Port that the Knora API uses config.adminuser : Name of admin user config.password : Password of admin user (use with caution)! server.has_openssl : true if OpenSSL is available. server.secure : true if the connection was made over HTTPS. server.host : the hostname of the Sipi server that was used in the request. server.client_ip : the IPv4 or IPv6 address of the client connecting to Sipi. server.client_port : the port number of the client socket. server.uri : the URL path used to access Sipi (does not include the hostname). server.header : a table containing all the HTTP request headers (in lowercase). server.cookies : a table of the cookies that were sent with the request. server.get : a table of GET request parameters. server.post : a table of POST or PUT request parameters. server.request : all request parameters. server.uploads : an array of upload parameters, one per file. Each one is a table containing: : - fieldname : the name of the form field. - origname : the original filename. - tmpname : a temporary path to the uploaded file. - mimetype : the MIME type of the uploaded file as provided by the browser. - filesize : the size of uploaded file in bytes. Lua helper functions helper.filename_hash success, filepath = helper.filename_hash(fileid) if subdir_levels (see configuration file) is > 0, recursive subdirectories named 'A', 'B',.., 'Z' are used to split the image files across multiple directories. A simple hash-algorithm is being used. This function returns a filepath with the subdirectories prepended, e.g gaga.jp2 becomes C/W/gaga.jpg Example: success, newfilepath = helper.filename_hash(newfilename[imgindex]); if not success then server.sendStatus(500) server.log(gaga, server.loglevel.LOG_ERR) return false end filename = config.imgroot .. '/' .. newfilepath Lua image functions There is an image object implemented which allows to manipulate and convert images. SipiImage.new(filename) The simple forms are: img = SipiImage.new(\"filename\") img = SipiImage.new(index) The first variant opens a file given by \"filename\", the second variant opens an uploaded file directly using the integer index to the uploaded files. If the index of an uploaded file is passed as an argument, this method adds additional metadata to the SipiImage object that is constructed: the file's original name, its MIME type, and its SHA256 checksum. When the SipiImage object is then written to another file, this metadata will be stored in an extra header record. If a filename is passed, the method does not add this metadata. The more complex form is as follows: img = SipiImage.new(\"filename\", { region=<iiif-region-string>, size=<iiif-size-string>, reduce=<integer>, original=origfilename, hash=\"md5\"|\"sha1\"|\"sha256\"|\"sha384\"|\"sha512\" }) This creates a new Lua image object and loads the given image into. The second form allows to indicate a region, the size or a reduce factor and the original filename. The hash parameter indicates that the given checksum should be calculated out of the pixel values and written into the header. SipiImage.dims() success, dims = img.dims() if success then server.print('nx=', dims.nx, ' ny=', dims.ny) end Returns the dimensions of the image. SipiImage.crop(<iiif-region-string>) success, errormsg = img.crop(<IIIF-region-string>) Crops the image to the given rectangular region. The parameter must be a valid IIIF-region string. SipiImage.scale(<iiif-size-string>) success, errormsg = img.scale(<iiif-size-string>) Resizes the image to the given size as iiif-conformant size string. SipiImage.rotate(<iiif-rotation-string>) success, errormsg = img.rotate(<iiif-rotation-string>) Rotates and/or mirrors the image according the given iiif-conformant rotation string. SipiImage.watermark(<wm-file-path>) success, errormsg = img.watermark(<wm-file-path>) Applies the given watermark file to the image. The watermark file must be a bitonal TIFF file. SipiImage.write(<filepath>) success, errormsg = img.write(<filepath>) success, errormsg = img.write('HTTP.jpg') The first version write the image to a file, the second writes the file to the HTTP connection. The file format is determined by the extension: jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file SipiImage.send(<format>) success, errormsg = img.send(<format>) Sends the file to the HTTP connection. As format are allowed: jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file Installing Lua modules To install Lua modules that can be used in Lua scripts, use local/bin/luarocks . Make sure that the location where the modules are stored is in the Lua package path, which is printed by local/bin/lurocks path. The Lua paths will be used by the Lua interpreter when loading modules in a script with require (see Using LuaRocks to install packages in the current directory ). For example, using local/bin/luarocks install --local package , the package will be installed in ~/.luarocks/ . To include this path in the Lua's interpreter package search path, you can use an environment variable. Running local/bin/luarocks path outputs the code you can use to do so. Alternatively, you can build the package path at the beginning of a Lua file by setting package.path and package.cpath (see Running scripts with packages ). Using SQLite in Lua Scripts Sipi supports SQLite 3 databases, which can be accessed from Lua scripts. You should use pcall to handle errors that may be returned by SQLite. Opening an SQLite Database db = sqlite('db/test.db', 'RW') This creates a new opaque database object. The first parameter is the path to the database file. The second parameter may be 'RO' for read-only access, 'RW' for read-write access, or 'CRW' for read-write access. If the database file does not exist, it will be created using this option. To destroy the database object and free all resources, you can do this: ``` {.sourceCode .none} db = ~db However, Lua's garbage collection will destroy the database object and free all resources when they are no longer used. ### Preparing a Query qry = db << 'SELECT * FROM image' Or, if you want to use a prepared query statement: qry = db << 'INSERT INTO image (id, description) VALUES (?,?)' `qry` will then be a query object containing a prepared query. If the query object is not needed anymore, it may be destroyed: ``` {.sourceCode .none} qry = ~qry Query objects should be destroyed explicitly if not needed any longer. Executing a Query row = qry() while (row) do print(row[0], ' -> ', row[1]) row = qry() end Or with a prepared statement: qry('SGV_1960_00315', 'This is an image of a steam engine...') The second way is used for prepared queries that contain parameters.","title":"Lua"},{"location":"lua/#customizing-sipi-with-lua-scripts","text":"Within Sipi, Lua is used to perform authentication and authorization for IIIF image requests, and to write custom routes. Sipi provides the Lua interpreter the LuaRocks package manager. Sipi does not use the system's Lua interpreter or package manager. The Lua interpreter in Sipi runs in a multithreaded environment: each request runs in its own thread and has its own Lua interpreter. Therefore, only Lua packages that are known to be thread-safe may be used.","title":"Customizing Sipi with Lua Scripts"},{"location":"lua/#custom-routes","text":"Custom routes can be defined in Sipi's configuration file using the routes configuration variable. For example: routes = { { method = 'GET', route = '/status', script = 'get_repository_status.lua' }, { method = 'POST', route = '/make_thumbnail', script = 'make_image_thumbnail.lua' } } Sipi looks for these scripts in the directory specified by scriptdir in its configuration file. The first route that matches the beginning of the requested URL path will be used.","title":"Custom Routes"},{"location":"lua/#authentication-and-authorization","text":"In Sipi's config file, initscript contains the path of a Lua script that defines a function called pre_flight . The function takes the parameters prefix , identifier and, cookie , and is called whenever an image is requested. The possible return values of the pre_flight function are as follows. Note that Lua function's return value may consist of more than one element (see Multiple Results ): Grant full permissions to access the file identified by filepath : return 'allow', filepath Grant restricted access to the file identified by filepath , in one of the following ways: : - Reduce the image dimensions, e.g. to the default thumbnail dimensions: return 'restrict:size=' .. \"config.thumb_size\", filepath - Render the image with a watermark: return restrict:watermark=<path-to-watermark>, filepath Deny access to the requested file: return 'deny' In the pre_flight function, permission checking can be implemented. When Sipi is used with Knora , the pre_flight function asks Knora about the user's permissions on the image (see sipi.init-knora.lua ). The scripts Knora_login.lua and Knora_logout.lua handle the setting and unsetting of a cookie containing the Knora session ID.","title":"Authentication and Authorization"},{"location":"lua/#file-uploads-to-sipi","text":"Using Lua it is possible to create an upload function for image files. See the scripts upload.elua and do-upload.elua in the server directory, or upload.lua in the scripts directory.","title":"File uploads to SIPI"},{"location":"lua/#sipi-functions-available-to-lua-scripts","text":"Sipi provides the following functions that can be called from Lua scripts. Each function returns two values. The first value is true if the operation succeeded, false otherwise. If the operation succeeded, the second value is the result of the operation, otherwise it is an error message.","title":"Sipi Functions Available to Lua Scripts"},{"location":"lua/#serversetbuffer","text":"success, errmsg = server.setBuffer([bufsize][,incsize]) Activates the the connection buffer. Optionally the buffer size and increment size can be given. Returns true, nil on success or false, errormsg on failure.","title":"server.setBuffer"},{"location":"lua/#serverfsftype","text":"success, filetype = server.fs.ftype(filepath) Checks the filetype of a given filepath. Returns either true, filetype (one of \"FILE\" , \"DIRECTORY\" , \"CHARDEV\" , \"BLOCKDEV\" , \"LINK\" , \"SOCKET\" or \"UNKNOWN\" ) or false, errormsg .","title":"server.fs.ftype"},{"location":"lua/#serverfsmodtime","text":"success, modtime = server.fs.modtime(filepath) Retrieves the last modification date of a file in seconds since epoch UTC. Returns either true , modtime or false , errormsg .","title":"server.fs.modtime"},{"location":"lua/#serverfsis95readable","text":"success, readable = server.fs.is_readable(filepath) Checks if a file is readable. Returns true, readable (boolean) on success or false, errormsg on failure.","title":"server.fs.is_readable"},{"location":"lua/#serverfsis95writeable","text":"success, writeable = server.fs.is_writeable(filepath) Checks if a file is writeable. Returns true, writeable (boolean) on success or false, errormsg on failure.","title":"server.fs.is_writeable"},{"location":"lua/#serverfsis95executable","text":"success, errormsg = server.fs.is_executable(filepath) Checks if a file is executable. Returns true, executable (boolean) on success or false, errormsg on failure.","title":"server.fs.is_executable"},{"location":"lua/#serverfsexists","text":"success, exists = server.fs.exists(filepath) Checks if a file exists. Checks if a file exists. Returns true, exists (boolean) on success or false, errormsg on failure.","title":"server.fs.exists"},{"location":"lua/#serverfsunlink","text":"success, errormsg = server.fs.unlink(filename) Deletes a file from the file system. The file must exist and the user must have write access. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.unlink"},{"location":"lua/#serverfsmkdir","text":"success, errormsg = server.fs.mkdir(dirname, [tonumber('0755', 8)]) Creates a new directory, optionally with the specified permissions. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.mkdir"},{"location":"lua/#serverfsrmdir","text":"success, errormsg = server.fs.rmdir(dirname) Deletes a directory. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.rmdir"},{"location":"lua/#serverfsgetcwd","text":"success, curdir = server.fs.getcwd() Gets the current working directory. Returns true, current_dir on success or false, errormsg on failure.","title":"server.fs.getcwd"},{"location":"lua/#serverfsreaddir","text":"success, filenames = server.fs.readdir(dirname) Gets the names of the files in a directory, not including . and .. . Returns true, table on success or false, errormsg on failure.","title":"server.fs.readdir"},{"location":"lua/#serverfschdir","text":"success, oldir = server.fs.chdir(newdir) Change working directory. Returns true, olddir on success or false, errormsg on failure.","title":"server.fs.chdir"},{"location":"lua/#serverfscopyfile","text":"success, errormsg = server.fs.copyFile(source, destination) Copies a file from source to destination. Returns true, nil on success or false, errormsg on failure.","title":"server.fs.copyFile"},{"location":"lua/#serverfsmovefile","text":"success, errormsg = server.fs.moveFile(from, to) Moves a file. The move connot cross filesystem boundaries! true, nil on success or false, errormsg on failure.","title":"server.fs.moveFile"},{"location":"lua/#serveruuid","text":"success, uuid = server.uuid() Generates a random UUID version 4 identifier in canonical form, as described in RFC 4122 . Returns true, uuid on success or false, errormsg on failure.","title":"server.uuid"},{"location":"lua/#serveruuid62","text":"success, uuid62 = server.uuid62() Generates a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure.","title":"server.uuid62"},{"location":"lua/#serveruuid95to95base62","text":"success, uuid62 = server.uuid_to_base62(uuid) Converts a canonical UUID string to a Base62-encoded UUID. Returns true, uuid62 on success or false, errormsg on failure.","title":"server.uuid_to_base62"},{"location":"lua/#serverbase6295to95uuid","text":"success, uuid = server.base62_to_uuid(uuid62) Converts a Base62-encoded UUID to canonical form. Returns true, uuid on success or false, errormsg on failure.","title":"server.base62_to_uuid"},{"location":"lua/#serverprint","text":"success, errormsg = server.print(values) Prints variables and/or strings to the HTTP connection. Returns true, nil on success or false, errormsg on failure.","title":"server.print"},{"location":"lua/#serverhttp","text":"success, result = server.http(method, \"http://server.domain[:port]/path/file\" [, header] [, timeout]) Performs an HTTP request. Parameters: method : The HTTP request method. Currently must be \"GET\" . url : The HTTP URL. header : An optional table of key-value pairs representing HTTP request headers. timeout : An optional number of milliseconds until the connection times out. Authentication is not yet supported. The result is a table: result = { status_code = value -- HTTP status code returned erromsg = \"error description\" -- only if success is false header = { name = value [, name = value, ...] }, certificate = { -- only if HTTPS connection subject = value, issuer = value }, body = data, duration = milliseconds } Example: success, result = server.http(\"GET\", \"http://www.salsah.org/api/resources/1\", 100) if (result.success) then server.print(\"<table>\") server.print(\"<tr><th>Field</th><th>Value</th></tr>\") for k,v in pairs(server.header) do server.print(\"<tr><td>\", k, \"</td><td>\", v, \"</td></tr>\") end server.print(\"</table><hr/>\") server.print(\"Duration: \", result.duration, \" ms<br/><hr/>\") server.print(\"Body:<br/>\", result.body) else server.print(\"ERROR: \", result.errmsg) end","title":"server.http"},{"location":"lua/#servertable95to95json","text":":: : success, jsonstr = server.table_to_json(table) Converts a (nested) Lua table to a JSON string. Returns true, jsonstr on success or false, errormsg on failure.","title":"server.table_to_json"},{"location":"lua/#serverjson95to95table","text":"success, table = server.json_to_table(jsonstr) Converts a JSON string to a (nested) Lua table. Returns true, table on success or false, errormsg on failure.","title":"server.json_to_table"},{"location":"lua/#serversendheader","text":"success, errormsg = server.sendHeader(key, value) Sets an HTTP response header. Returns true, nil on success or false, errormsg on failure.","title":"server.sendHeader"},{"location":"lua/#serversendcookie","text":"success, errormsg = server.sendCookie(key, value [, options-table]) Sets a cookie in the HTTP response. Returns true, nil on success or false, errormsg on failure. The optional options-table is a Lua table containing the following keys: path domain expires (value in seconds) secure (boolean) http_only (boolean)","title":"server.sendCookie"},{"location":"lua/#serversendstatus","text":"server.sendStatus(code) Sends an HTTP status code. This function is always successful and returns nothing.","title":"server.sendStatus"},{"location":"lua/#servergenerate95jwt","text":"success, token = server.generate_jwt(table) Generates a JSON Web Token (JWT) with the table as payload. Returns true, token on success or false, errormsg on failure. The table contains the JWT claims as follows. (The type IntDate is a number of seconds since 1970-01-01T0:0:0Z): iss (string => StringOrURI) OPT: principal that issued the JWT. exp (number => IntDate) OPT: expiration time on or after which the token MUST NOT be accepted for processing. nbf (number => IntDate) OPT: identifies the time before which the token MUST NOT be accepted for processing. iat (number => IntDate) OPT: identifies the time at which the JWT was issued. aud (string => StringOrURI) OPT: identifies the audience that the JWT is intended for. The audience value is a string, typically the base address of the resource being accessed, such as https://contoso.com . prn (string => StringOrURI) OPT: identifies the subject of the JWT. jti (string => String) OPT: provides a unique identifier for the JWT.","title":"server.generate_jwt"},{"location":"lua/#serverdecode95jwt","text":"success, table = server.decode_jwt(token) Decodes a JSON Web Token (JWT) and returns its content as table. Returns true, table on success or false, errormsg on failure.","title":"server.decode_jwt"},{"location":"lua/#serverfile95mimetype","text":"success, table = server.file_mimetype(path) success, table = server.file_mimetype(index) Determines the mimetype of a file. The first form is used if the file path is known. The second form can be used for uploads by passing the file index. It returns true, table on success or false, errormsg on failure. The table has 2 members: - mimetype - charset","title":"server.file_mimetype"},{"location":"lua/#serverrequireauth","text":"success, table = server.requireAuth() Gets HTTP authentication data. Returns true, table on success or false, errormsg on failure. The result is a table: { status = string -- \"BASIC\" | \"BEARER\" | \"NOAUTH\" (no authorization header) | \"ERROR\" username = string -- only if status = \"BASIC\" password = string -- only if status = \"BASIC\" token = string -- only if status = \"BEARER\" message = string -- only if status = \"ERROR\" } Example: success, auth = server.requireAuth() if not success then server.sendStatus(501) server.print(\"Error in getting authentication scheme!\") return -1 end if auth.status == 'BASIC' then -- -- everything OK, let's create the token for further calls and ad it to a cookie -- if auth.username == config.adminuser and auth.password == config.password then tokendata = { iss = \"sipi.unibas.ch\", aud = \"knora.org\", user = auth.username } success, token = server.generate_jwt(tokendata) if not success then server.sendStatus(501) server.print(\"Could not generate JWT!\") return -1 end success, errormsg = server.sendCookie('sipi', token, {path = '/', expires = 3600}) if not success then server.sendStatus(501) server.print(\"Couldn't send cookie with JWT!\") return -1 end else server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') server.print(\"Wrong credentials!\") return -1 end elseif auth.status == 'BEARER' then success, jwt = server.decode_jwt(auth.token) if not success then server.sendStatus(501) server.print(\"Couldn't deocde JWT!\") return -1 end if (jwt.iss ~= 'sipi.unibas.ch') or (jwt.aud ~= 'knora.org') or (jwt.user ~= config.adminuser) then server.sendStatus(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end elseif auth.status == 'NOAUTH' then server.setBuffer() server.sendStatus(401); server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 else server.status(401) server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"') return -1 end","title":"server.requireAuth"},{"location":"lua/#servercopytmpfile","text":"success, errormsg = server.copyTmpfile() Sipi saves each uploaded file in a temporary location (given by the config variable tmpdir ) and deletes it after the request has been served. This function is used to copy the file to another location where it can be retrieved later. Returns true, nil on success or false, errormsg on failure.","title":"server.copyTmpfile"},{"location":"lua/#serversystime","text":"systime = server.systime() Returns the current system time on the server in seconds since epoch.","title":"server.systime"},{"location":"lua/#serverlog","text":"server.log(message, loglevel) Writes a message to syslog . Severity levels are: server.loglevel.LOG_EMERG server.loglevel.LOG_ALERT server.loglevel.LOG_CRIT server.loglevel.LOG_ERR server.loglevel.LOG_WARNING server.loglevel.LOG_NOTICE server.loglevel.LOG_INFO server.loglevel.LOG_DEBUG","title":"server.log"},{"location":"lua/#sipi-variables-available-to-lua-scripts","text":"config.hostname : Hostname where SIPI runs on config.port : Portnumber where SIPI communicates (non SSL) config.sslport : Portnumber for SSL connections of SIPI config.imgroot : Root directory for IIIF-served images config.docroot : Root directory for WEB-Server config.max_temp_file_age : maximum age of temporary files config.prefix_as_path : true if the prefix should be used as internal path image directories config.init_script : Path to initialization script config.scriptdir : Path to script directory config.cache_dir : Path to cache directory for iIIF served images config.cache_size : Maximal size of cache config.cache_n_files : Maximal number of files in cache config.cache_hysteresis : Amount fo data to be purged if cache reaches maximum size config.keep_alive : keep alive time config.thumb_size : Default thumbnail image size config.n_threads : Number of threads SIPI uses config.max_post_size : Maximal size of POST data allowed config.tmpdir : Temporary directory to store uploads config.knora_path : Path to knora REST API (only for SIPI used with Knora) config.knora_port : Port that the Knora API uses config.adminuser : Name of admin user config.password : Password of admin user (use with caution)! server.has_openssl : true if OpenSSL is available. server.secure : true if the connection was made over HTTPS. server.host : the hostname of the Sipi server that was used in the request. server.client_ip : the IPv4 or IPv6 address of the client connecting to Sipi. server.client_port : the port number of the client socket. server.uri : the URL path used to access Sipi (does not include the hostname). server.header : a table containing all the HTTP request headers (in lowercase). server.cookies : a table of the cookies that were sent with the request. server.get : a table of GET request parameters. server.post : a table of POST or PUT request parameters. server.request : all request parameters. server.uploads : an array of upload parameters, one per file. Each one is a table containing: : - fieldname : the name of the form field. - origname : the original filename. - tmpname : a temporary path to the uploaded file. - mimetype : the MIME type of the uploaded file as provided by the browser. - filesize : the size of uploaded file in bytes.","title":"Sipi Variables Available to Lua Scripts"},{"location":"lua/#lua-helper-functions","text":"","title":"Lua helper functions"},{"location":"lua/#helperfilename95hash","text":"success, filepath = helper.filename_hash(fileid) if subdir_levels (see configuration file) is > 0, recursive subdirectories named 'A', 'B',.., 'Z' are used to split the image files across multiple directories. A simple hash-algorithm is being used. This function returns a filepath with the subdirectories prepended, e.g gaga.jp2 becomes C/W/gaga.jpg Example: success, newfilepath = helper.filename_hash(newfilename[imgindex]); if not success then server.sendStatus(500) server.log(gaga, server.loglevel.LOG_ERR) return false end filename = config.imgroot .. '/' .. newfilepath","title":"helper.filename_hash"},{"location":"lua/#lua-image-functions","text":"There is an image object implemented which allows to manipulate and convert images.","title":"Lua image functions"},{"location":"lua/#sipiimagenewfilename","text":"The simple forms are: img = SipiImage.new(\"filename\") img = SipiImage.new(index) The first variant opens a file given by \"filename\", the second variant opens an uploaded file directly using the integer index to the uploaded files. If the index of an uploaded file is passed as an argument, this method adds additional metadata to the SipiImage object that is constructed: the file's original name, its MIME type, and its SHA256 checksum. When the SipiImage object is then written to another file, this metadata will be stored in an extra header record. If a filename is passed, the method does not add this metadata. The more complex form is as follows: img = SipiImage.new(\"filename\", { region=<iiif-region-string>, size=<iiif-size-string>, reduce=<integer>, original=origfilename, hash=\"md5\"|\"sha1\"|\"sha256\"|\"sha384\"|\"sha512\" }) This creates a new Lua image object and loads the given image into. The second form allows to indicate a region, the size or a reduce factor and the original filename. The hash parameter indicates that the given checksum should be calculated out of the pixel values and written into the header.","title":"SipiImage.new(filename)"},{"location":"lua/#sipiimagedims","text":"success, dims = img.dims() if success then server.print('nx=', dims.nx, ' ny=', dims.ny) end Returns the dimensions of the image.","title":"SipiImage.dims()"},{"location":"lua/#sipiimagecropiiif-region-string","text":"success, errormsg = img.crop(<IIIF-region-string>) Crops the image to the given rectangular region. The parameter must be a valid IIIF-region string.","title":"SipiImage.crop(&lt;iiif-region-string&gt;)"},{"location":"lua/#sipiimagescaleiiif-size-string","text":"success, errormsg = img.scale(<iiif-size-string>) Resizes the image to the given size as iiif-conformant size string.","title":"SipiImage.scale(&lt;iiif-size-string&gt;)"},{"location":"lua/#sipiimagerotateiiif-rotation-string","text":"success, errormsg = img.rotate(<iiif-rotation-string>) Rotates and/or mirrors the image according the given iiif-conformant rotation string.","title":"SipiImage.rotate(&lt;iiif-rotation-string&gt;)"},{"location":"lua/#sipiimagewatermarkwm-file-path","text":"success, errormsg = img.watermark(<wm-file-path>) Applies the given watermark file to the image. The watermark file must be a bitonal TIFF file.","title":"SipiImage.watermark(&lt;wm-file-path&gt;)"},{"location":"lua/#sipiimagewritefilepath","text":"success, errormsg = img.write(<filepath>) success, errormsg = img.write('HTTP.jpg') The first version write the image to a file, the second writes the file to the HTTP connection. The file format is determined by the extension: jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file","title":"SipiImage.write(&lt;filepath&gt;)"},{"location":"lua/#sipiimagesendformat","text":"success, errormsg = img.send(<format>) Sends the file to the HTTP connection. As format are allowed: jpg : writes a JPEG file tif : writes a TIFF file png : writes a png file jpx : writes a JPGE2000 file","title":"SipiImage.send(&lt;format&gt;)"},{"location":"lua/#installing-lua-modules","text":"To install Lua modules that can be used in Lua scripts, use local/bin/luarocks . Make sure that the location where the modules are stored is in the Lua package path, which is printed by local/bin/lurocks path. The Lua paths will be used by the Lua interpreter when loading modules in a script with require (see Using LuaRocks to install packages in the current directory ). For example, using local/bin/luarocks install --local package , the package will be installed in ~/.luarocks/ . To include this path in the Lua's interpreter package search path, you can use an environment variable. Running local/bin/luarocks path outputs the code you can use to do so. Alternatively, you can build the package path at the beginning of a Lua file by setting package.path and package.cpath (see Running scripts with packages ).","title":"Installing Lua modules"},{"location":"lua/#using-sqlite-in-lua-scripts","text":"Sipi supports SQLite 3 databases, which can be accessed from Lua scripts. You should use pcall to handle errors that may be returned by SQLite.","title":"Using SQLite in Lua Scripts"},{"location":"lua/#opening-an-sqlite-database","text":"db = sqlite('db/test.db', 'RW') This creates a new opaque database object. The first parameter is the path to the database file. The second parameter may be 'RO' for read-only access, 'RW' for read-write access, or 'CRW' for read-write access. If the database file does not exist, it will be created using this option. To destroy the database object and free all resources, you can do this: ``` {.sourceCode .none} db = ~db However, Lua's garbage collection will destroy the database object and free all resources when they are no longer used. ### Preparing a Query qry = db << 'SELECT * FROM image' Or, if you want to use a prepared query statement: qry = db << 'INSERT INTO image (id, description) VALUES (?,?)' `qry` will then be a query object containing a prepared query. If the query object is not needed anymore, it may be destroyed: ``` {.sourceCode .none} qry = ~qry Query objects should be destroyed explicitly if not needed any longer.","title":"Opening an SQLite Database"},{"location":"lua/#executing-a-query","text":"row = qry() while (row) do print(row[0], ' -> ', row[1]) row = qry() end Or with a prepared statement: qry('SGV_1960_00315', 'This is an image of a steam engine...') The second way is used for prepared queries that contain parameters.","title":"Executing a Query"},{"location":"running/","text":"Running Sipi After following the instructions in building, you will find the executable local/bin/sipi in the source tree. It can be run either as simple command-line image converter or as a server. Running Sipi As a Command-line Image Converter Convert an image file to another format: local/bin/sipi --format [output format] --fileIn [input file] [output file] Compare two image files: local/bin/sipi --Compare file1 --Compare file2 Running Sipi As a Server local/bin/sipi --config [config file] Sipi logs its operations using syslog . Command-line Options Options: --config filename, -c filename Configuration file for web server. --file fileIn, -f fileIn input file to be converted. Usage: sipi [options] -f fileIn fileout --format Value, -F Value Output format Value can be: jpx,jpg,tif,png. --ICC Value, -I Value Convert to ICC profile. Value can be: none,sRGB,AdobeRGB,GRAY. --quality Value, -q Value Quality (compression). Value can any integer between 1 and 100 --region x,y,w,h, -r x,y,w,h Select region of interest, where x,y,w,h are integer values --Reduce Value, -R Value Reduce image size by factor Value (cannot be used together with --size and --scale) --size w,h -s w,h Resize image to given size w,h (cannot be used together with --reduce and --scale) --Scale Value, -S Value Resize image by the given percentage Value (cannot be used together with --size and --reduce) --skipmeta Value, -k Value Skip the given metadata. Value can be none,all --mirror Value, -m Value Mirror the image. Value can be: none,horizontal,vertical --rotate Value, -o Value Rotate the image. by degree Value, angle between (0:360) --salsah, -s Special flag for SALSAH internal use --Compare file1 --Compare file2 or -C file1 -C file2 Compare two files --watermark file, -w file Add a watermark to the image --serverport Value, -p Value Port of the web server --nthreads Value, -t Value Number of threads for web server --imgroot Value, -i Value Root directory containing the images for the web server --loglevel Value, -l Value Logging level Value can be: DEBUG,INFO,NOTICE,WARNING,ERR,CRIT,ALERT,EMERG --help Print usage and exit. Configuration Files Sipi's configuration file is written in Lua . You can make your own configuration file by adapting config/sipi.config.lua . Check that the port number is correct and that your operating system's firewall does not block it. Set imgroot to the directory containing the files to be served. Create the directory cache in the top-level directory of the source tree. For more information, see the comments in config/sipi.config.lua . Using Sipi with Knora If you are using Sipi with Knora , you can adapt config/sipi.knora-config.lua . HTTPS Support Sipi supports SSL/TLS encryption if the OpenSSL library is installed. You will need to install a certificate; see config/sipi.config.lua for instructions. IIIF Prefixes Sipi supports IIIF image URLs . If the configuration property prefix_as_path is set to true , the IIIF prefix portion of the URL is interpreted as a subdirectory of imgroot , and Sipi looks for the requested image file in that subdirectory. Otherwise, it looks for the file in imgroot .","title":"Running"},{"location":"running/#running-sipi","text":"After following the instructions in building, you will find the executable local/bin/sipi in the source tree. It can be run either as simple command-line image converter or as a server.","title":"Running Sipi"},{"location":"running/#running-sipi-as-a-command-line-image-converter","text":"Convert an image file to another format: local/bin/sipi --format [output format] --fileIn [input file] [output file] Compare two image files: local/bin/sipi --Compare file1 --Compare file2","title":"Running Sipi As a Command-line Image Converter"},{"location":"running/#running-sipi-as-a-server","text":"local/bin/sipi --config [config file] Sipi logs its operations using syslog .","title":"Running Sipi As a Server"},{"location":"running/#command-line-options","text":"Options: --config filename, -c filename Configuration file for web server. --file fileIn, -f fileIn input file to be converted. Usage: sipi [options] -f fileIn fileout --format Value, -F Value Output format Value can be: jpx,jpg,tif,png. --ICC Value, -I Value Convert to ICC profile. Value can be: none,sRGB,AdobeRGB,GRAY. --quality Value, -q Value Quality (compression). Value can any integer between 1 and 100 --region x,y,w,h, -r x,y,w,h Select region of interest, where x,y,w,h are integer values --Reduce Value, -R Value Reduce image size by factor Value (cannot be used together with --size and --scale) --size w,h -s w,h Resize image to given size w,h (cannot be used together with --reduce and --scale) --Scale Value, -S Value Resize image by the given percentage Value (cannot be used together with --size and --reduce) --skipmeta Value, -k Value Skip the given metadata. Value can be none,all --mirror Value, -m Value Mirror the image. Value can be: none,horizontal,vertical --rotate Value, -o Value Rotate the image. by degree Value, angle between (0:360) --salsah, -s Special flag for SALSAH internal use --Compare file1 --Compare file2 or -C file1 -C file2 Compare two files --watermark file, -w file Add a watermark to the image --serverport Value, -p Value Port of the web server --nthreads Value, -t Value Number of threads for web server --imgroot Value, -i Value Root directory containing the images for the web server --loglevel Value, -l Value Logging level Value can be: DEBUG,INFO,NOTICE,WARNING,ERR,CRIT,ALERT,EMERG --help Print usage and exit.","title":"Command-line Options"},{"location":"running/#configuration-files","text":"Sipi's configuration file is written in Lua . You can make your own configuration file by adapting config/sipi.config.lua . Check that the port number is correct and that your operating system's firewall does not block it. Set imgroot to the directory containing the files to be served. Create the directory cache in the top-level directory of the source tree. For more information, see the comments in config/sipi.config.lua .","title":"Configuration Files"},{"location":"running/#using-sipi-with-knora","text":"If you are using Sipi with Knora , you can adapt config/sipi.knora-config.lua .","title":"Using Sipi with Knora"},{"location":"running/#https-support","text":"Sipi supports SSL/TLS encryption if the OpenSSL library is installed. You will need to install a certificate; see config/sipi.config.lua for instructions.","title":"HTTPS Support"},{"location":"running/#iiif-prefixes","text":"Sipi supports IIIF image URLs . If the configuration property prefix_as_path is set to true , the IIIF prefix portion of the URL is interpreted as a subdirectory of imgroot , and Sipi looks for the requested image file in that subdirectory. Otherwise, it looks for the file in imgroot .","title":"IIIF Prefixes"},{"location":"0-release-notes/","text":"v1.x.x Release Notes v1.2.0 Release Notes See the release120 on Github. New features: Bugfixes: v1.3.0 Release Notes See the release130 on Github. New features: Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests Bugfixes: 16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed v1.4.0 Release Notes See the release140 on Github. New features: Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests Bugfixes: 16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed v1.5.0-SNAPSHOT Release Notes (not released yet) See the release150 on Github. New features: Add path for getting original filename and mimetype Add More functions for lua Add Lua clean_tempdir() function for cleaning up old temporary files. Add server.fs.readdir C++ function for Lua. Add config setting for maximum temp file age. Remove unimplemented log levels TRACE and OFF from docs and configs. Add e2e test of clean_tempdir(). Use clearer names in knora.json response. Log all internal server errors in send_error. Add more features for Knora integration Improve server.post doc. Add some improvements Don't process a payload in an HTTP DELETE request. See https://tools.ietf.org/html/rfc7231#section-4.3.5 : \"A payload within a DELETE request message has no defined semantics; sending a payload body on a DELETE request might cause some existing implementations to reject the request.\" Improve SipiImage.new documentation. Update Kakadu to version v7_A_5-01382N Bugfixes: Fix unittest Fix to support Essential metadata Fix incorrect log level names in Lua scripts. Fix inconsistencies in log level names (use syslog's names everywhere). Fix documentation syntax.","title":"Release-Notes"},{"location":"0-release-notes/#v1xx-release-notes","text":"","title":"v1.x.x Release Notes"},{"location":"0-release-notes/#v120-release-notes","text":"See the release120 on Github.","title":"v1.2.0 Release Notes"},{"location":"0-release-notes/#new-features","text":"","title":"New features:"},{"location":"0-release-notes/#bugfixes","text":"","title":"Bugfixes:"},{"location":"0-release-notes/#v130-release-notes","text":"See the release130 on Github.","title":"v1.3.0 Release Notes"},{"location":"0-release-notes/#new-features_1","text":"Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests","title":"New features:"},{"location":"0-release-notes/#bugfixes_1","text":"16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed","title":"Bugfixes:"},{"location":"0-release-notes/#v140-release-notes","text":"See the release140 on Github.","title":"v1.4.0 Release Notes"},{"location":"0-release-notes/#new-features_2","text":"Added latest kakadu version v7_A_4-01727L.zip support for CIELab for both 8- and 16-bit images try/catch for ICC profiles that are not supported by kakadu. These profiles are added to the \"essential metadata\" in order to be reinstated if the JPX is converted back to a TIFF or JPEG. added more unit tests","title":"New features:"},{"location":"0-release-notes/#bugfixes_2","text":"16 Bit PNG images are now teated correctly by byteswapping of the data (htons), since PNG uses network byte order which is usually noit zthe host byte order on intel processors alpha channels are treated correctly with JPEG2000 The parameter names in a multidata/form-data POST request now have the double quotes removed","title":"Bugfixes:"},{"location":"0-release-notes/#v150-snapshot-release-notes-not-released-yet","text":"See the release150 on Github.","title":"v1.5.0-SNAPSHOT Release Notes (not released yet)"},{"location":"0-release-notes/#new-features_3","text":"Add path for getting original filename and mimetype Add More functions for lua Add Lua clean_tempdir() function for cleaning up old temporary files. Add server.fs.readdir C++ function for Lua. Add config setting for maximum temp file age. Remove unimplemented log levels TRACE and OFF from docs and configs. Add e2e test of clean_tempdir(). Use clearer names in knora.json response. Log all internal server errors in send_error. Add more features for Knora integration Improve server.post doc. Add some improvements Don't process a payload in an HTTP DELETE request. See https://tools.ietf.org/html/rfc7231#section-4.3.5 : \"A payload within a DELETE request message has no defined semantics; sending a payload body on a DELETE request might cause some existing implementations to reject the request.\" Improve SipiImage.new documentation. Update Kakadu to version v7_A_5-01382N","title":"New features:"},{"location":"0-release-notes/#bugfixes_3","text":"Fix unittest Fix to support Essential metadata Fix incorrect log level names in Lua scripts. Fix inconsistencies in log level names (use syslog's names everywhere). Fix documentation syntax.","title":"Bugfixes:"}]}